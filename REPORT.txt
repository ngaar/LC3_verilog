- Team members (one submission per team)

    For each member:

      * Nathan Gaar
      * ncg263
      * wrote tests, design and code

      *Chelsea Rusch
      *
      *wrote tests, and fixed the broken test Nathan pushed, design and code

- Initial proposal:
	Chelsea and I are going to do an implementation of the LC3 instruction set. 
	Due to time constraints, there are some instructions like system calls and 
	return form interrupts that we likely just can't complete.


- What did you implement?
  We implemented the LC3 architecture in verilog. This instruction set is a learning tool, similar
  to y86 but has quite a few instructions. Our group completed 15 instructions out of the 19 
  instructions LC3 has. This implimentation takes into account data hazards and is pipelined. The instructions not completed deal
 with traps and system calls. 
   
  Twos complement addition is also avaiable. For most instructions, a leading bit of 1 in the offset value will produce
  a negative number.

   
  The instructions we implemented:
        OPCODE     
      15 14 13 12|11 10 9 8 7 6 5 4 3 2 1 0
  ADD+ 0  0  0 1 |   DR  | SR1 |0|0 0|SR2  
  ADD+ 0  0  0 1 |   DR  | SR1 |1|immed val
  AND+ 0  1  0 1 |   DR  | SR1 |0|0 0|SR2 
  AND+ 0  1  0 1 |   DR  | SR1 |1|immed val
  JMP  1  1  0 0 | 0 0  0|Base |0 0 0 0 0 0
  LD+  0  0  1 0 |   DR  | PCoffset9 bit number
  LDI+ 0  1  1 0 |   DR  | PCoffset9 bit number
  LDR+ 0  1  1 0 |   DR  |Base | offset6 bit 
  LEA  1  1  1 0 |   DR  |  PCoffset9 bit
  NOT+ 1  0  0 1 |   DR  | SR  |1 1 1 1 1 1
  ST   0  0  1 1 |   SR  | PCoffset9 bit number
  STI  1  0  1 1 |   SR  | PCoffset9 bit number
  STR  0  1  1 1 |   SR  | BASE |  offset6 bit
  MOV  1  1  0 1 |   DR  | 9 bit bit imme number

 ADD: dr = sr1 + sr2
 ADD: dr = sr1 + immed_val
 AND: dr = sr1 && sr2
 AND: dr = sr1 && immed_val
 JMP: PC = baseR
 LD:  dr = mem[pc + offset]
 LDI: dr = mem[mem[baser + offset]]
 LDR: dr = mem[baser + offset]
 LEA: dr = pc + offset
 NOT: dr = ~sr
 ST : mem[pc + offset] = sr
 STI: mem[mem[pc+ offset]] = sr
 STR: mem[baser + offset] = sr
 MOV: dr = 9 bit offset  

 
 DR: Destination register
 SR1: Source Register
 SR2: Source Register
 PCoffset9 : indicates the 9 bit number + PC
 PCoffset6 : indicated the 6 bit number + PC
 BASE: register value (base register) 

- Running instructions (concrete and concise):

    For example:

        - make clean
        - make clean test
        - make clean test should run our whole test suite

- What was difficult?

  With lots of experience in design already, getting the project started was not difficult at all.
  We were able to implement familiar  instructions relatively quickly, but we started to run into 
  difficulty with indirect instructions. For example, for STI (store indirect), two reads from memory 
  are required. This makes stalling and dealing with hazards much more difficult. For STI,
  the instruction sets mem[mem[PC + PCoffset9]] = SR. There is an equivalant load instruction LDI 
  that reads memory twice as well. These Indirect reads were definitely the most difficult part of the assignment.
  We resolved most data hazards except for the load and store indirect values. So, there are still data hazards that exit.
 

- What did you learn?

  Overall, the most enjoyable part of the project was realizing how much we've learned this semester. Earlier projects
  were quite difficult and this instruction set dwarfs most the instructions we were previously assigned. And yet, the project
  was completed without too much difficulty. 

  Some of the more enoyable parts were implementing the bitwise logic instructions and also the twos compliment logic. 
  Also, the project illuminated us to the fact that there are some really difficult designs avaialble that require 
  a lot of work and knowledge. Specifically, the indirect values challenged us and made us rethink some aspects of our pipelined project.
